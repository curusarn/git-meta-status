#!/usr/bin/env bash

set -u

print_help() {
    echo "USAGE: rgit ACTION"
    echo " "
    echo "Too alpha to have reaonable help"
    echo " "
    echo "ACTIONS: "
    echo "         raw PATH              Shows specified rgit files for current repo"
    echo "         help                  Shows this help"
    echo " "
}


# returns unique indentifier for a current repo based on origin remote address
repo_id() {
    if [[ ! -d ".git" ]]; then
        echo "ERR: <`pwd`> is not a git repository!"
        print_help
        exit 10
    fi
    if [ "${OPT_dotfiles}" == true ]; then
        remote=`eval "$dotfiles_git_cmd remote -v" | grep origin | tr ' ' '\t' | cut -f2 | head -n 1`
    else
        remote=`git remote -v | grep origin | tr ' ' '\t' | cut -f2 | head -n 1`
    fi
    if [[ "$remote" != *"@"* ]]; then
        # remote is https: transform to ssh
        host=`echo "$remote" | cut -d'/' -f3`
        repo=`echo "$remote" | cut -d'/' -f4-`

        remote="git@$host:$repo"
    fi
    # keep the part between the '@' and '.git' | replace ':' with '/' 
    echo "$remote" | sed 's/^[a-zA-Z \t]*@//;s/\.git$//' | tr -s ':' '/'
}

require() {
    if [ "$1" ]; then
        echo "ERR: <$1> directory does not exist"
        echo "ERR: Not enough arguments - found <$#>, required 1 or more - exiting!"
        print_help
         
    fi

}

curr_repo_rgit_path() {
    local ret
    ret="`curr_repo_rgit_path`"
    if [[ ! -d "$ret" ]]; then
        echo "ERR: <$save_dir> is not a tracked repository"
        print_help
        exit 2 
    fi
}

# returns rgit path for current repo
# checks if dir exists
curr_repo_rgit_path() {
    local ret
    ret="$rgit_path/data/`repo_id`"
    echo "$ret"
}

data_pull() {
    if [[ ! -d "$rgit_path/.git" ]]; then
        echo "WARN: No .git directory <$rgit_path/.git>"\
             " - cloning <$rgit_remote>!"
        [[ ! -d "$rgit_path" ]] && mkdir -p "$rgit_path"
        if ! git clone "$rgit_remote" "$rgit_path"; then
            echo "ERR: Clonning <$rgit_remote> failed - exiting!"
            print_help
            exit 20
        fi
    fi
    cd "$rgit_path" 
    git pull 
    cd "$save_dir" 
}

data_record() {
    if [[ ! -d "$git_root" ]]; then 
        echo "ERR: git_root <$git_root> does not exist"
        print_help
        exit 30 
    fi
    if [[ ! -d "$rgit_path/.git" ]]; then
        echo "ERR: Directory <$rgit_path/.git> does not exist"
        print_help
        exit 31 
    fi
    cd "$git_root" 
    for repo in *; do
        cd "$git_root/$repo"
        if [[ ! -d .git ]]; then
            echo "WARN: <$git_root/$repo> is not a git repository - skipping!"
            continue
        fi
        
        path="`curr_repo_rgit_path`/$device_id"

        [[ -d "$path" ]] && rm -r "$path" # add -f after testing
        [[ ! -d "$path" ]] && mkdir -p "$path"
        pwd

        git rev-parse HEAD > "$path/HEAD"
        git rev-parse --short HEAD > "$path/HEAD_short"
        git status --short > "$path/status_short"
        git status > "$path/status"
        git cherry -v > "$path/cherry_v"
        git log --max-count "$git_depth" --graph --oneline > "$path/log_graph_oneline"
        git log --max-count "$git_depth" --oneline > "$path/log_oneline"
        git log --max-count "$git_depth" --pretty="%H" > "$path/log_H"
        git branch --verbose > "$path/branch_verbose"
        [[ ! -d "$path/diff" ]] && mkdir "$path/diff"
        for hash in `git cherry -v | cut -d' ' -f2`; do
            git diff "$hash^" "$hash" > "$path/diff/$hash"
        done
        git diff --staged > "$path/diff/staged"
        git diff > "$path/diff/unstaged"
    done
    cd "$save_dir"
}

data_commit() {
    if [[ ! -d "$rgit_path/.git" ]]; then
        echo "ERR: Directory <$rgit_path/.git> does not exist"
        print_help
        exit 40 
    fi
    cd "$rgit_path" 
    git add .
    if git diff --cached --exit-code >/dev/null; then
        echo "WARN: Git states did not change - nothing to commit."
    else
        echo "commit"
        if [[ -z ${1+x} ]]; then
            git commit -m "Device: $device_id"
        else
            git commit -m "$1"
        fi
    fi
    cd "$save_dir" 
}

data_push() {
    if [[ ! -d "$rgit_path/.git" ]]; then
        echo "ERR: Directory <$rgit_path/.git> does not exist"
        print_help
        exit 50 
    fi
    cd "$rgit_path" 

    if [[ -z "`git cherry -v`" ]]; then
        echo "WARN: Git states did not change - nothing to push."
    else
        echo "push"
        git push 
    fi

    cd "$save_dir" 
}

if [ $# -lt 1 ]; then
    echo "ERR: Not enough arguments - found <$#>, required 1 or more - exiting!"
    print_help
    exit 1
fi

config_path=~/.config/git-meta-status.sh

# default config
git_root=~/git
rgit_path=~/.rgit
git_depth=24
dotfiles_git_cmd=""

# load config if exists
if [ -f "$config_path" ]; then 
    source "$config_path"
else
    echo "WARN: config file <$config_path> does not exist"\
         " - consider creating it."
fi

save_dir="`pwd`"
[ ! -d "$curr_repo_path" ] && curr_repo_path=""

# init options
OPT_dotfiles=false

# get options first
arg_count=0
for arg in "$@"; do
    case "$arg" in
        --dotfiles|-d)
            if [[ -z "$dotfiles_git_cmd" ]]; then
                echo "ERR: \$dotfiles_git_cmd is not set - cannot use --dotfiles option"
                print_help
                exit 2
            fi
            OPT_dotfiles=true
            ;;
        --*|-*)
            echo "ERR: Unknown option <$arg> - exiting!"
            print_help
            exit 1
            ;;
        *)
            let "arg_count++"
            ;;
    esac
done

# get positional args
idx=0
declare -a pargs 
for arg in "$@"; do
    case "$arg" in
        --*|-*)
            : # do nothing
            ;;
        *)
            pos_args[idx]="$arg"
            let "idx++"
            ;;
    esac
done

case ${pargs[0]} in
    help)
        print_help
        exit 0
        ;;
    raw)
        path=`curr_repo_rgit_path`

        ;;
    data)
        if [ $# -lt 2 ]; then
            echo "ERR: Not data action found - exiting!"
            print_help
            exit 2
        fi
        case $2 in
            session-exit)
                meta_pull
                meta_record
                meta_commit
                meta_push
                ;;
            actions)
                get_actions
                ;;
            devices)
                cat "$rgit_path/devices"
                ;;
            meta_actions)
                echo "session-start session-exit init actions devices meta_actions diffs"
                ;;
            diffs)
                if [[ $# -lt 3 ]]; then 
                    echo "ERR: No device for 'igit meta diffs DEVICE' command - exiting!"
                    print_help
                    exit 5
                fi
                get_diffs "$3"
                ;;
        esac
        ;;
    diff)
        if [[ $# -lt 3 ]]; then
            echo "ERR: Not enough arguments for 'igit diff DEVICE COMMITISH' command - exiting!"
            print_help
            exit 5
        fi
        path="`curr_repo_rgit_path`"
        cd $path  
        if [[ ! -f "$2/diff/$3" ]]; then
            echo "ERR: File <$2/diff/$3> does not exist - exiting!"
            print_help
            exit 5
        fi
        cat $2/diff/$3 
        ;;
    *)
        path="`curr_repo_rgit_path`"
        cd $path  
        if [[ $# -lt 2 ]]; then
            hits=0 
            for device in *; do
                [[ ! -f "$device/$1" ]] && continue
                printf "[igit] Device <%s>:\n" "$device"
                cat "$device/$1"
                let "hits++"
            done
            if [[ $hits -eq 0 ]]; then 
                echo "ERR: Invalid action <$1>"
                print_help
                exit 3
            fi
        else
            if [[ ! -f "$2/$1" ]]; then 
                echo "ERR: Invalid action <$1> and device <$2> combination."
                print_help
                exit 4
            else
                cat $2/$1
            fi
        fi
        #echo $actions
        ;;
esac
