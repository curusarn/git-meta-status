#!/usr/bin/env bash

config_path=~/.config/git-meta-status.sh

set -u

print_help() {
    echo "USAGE: igit ACTION"
    echo " "
    echo "ACTIONS: "
    echo "         meta META_ACTION      "
    echo "         status [DEVICE]       Shows all git states of all machines"
    echo "         help                  Shows this help"
    echo " "
    echo "META_ACTIONS: "
    echo "         session-exit          Saves local git states to remote repository"
    echo "         session-start         Pulls remote git states from remote repository"
    echo "         device                Pulls remote git states from remote repository"
    echo "         init                  Sets up igit data"
}

# returns unique indentifier for a current repo based on origin remote address
uniq_git_repo_path() {
    if [[ ! -d ".git" ]]; then
        echo "ERR: <`pwd`> is not a git repository!"
        print_help
        exit 10
    fi
    remote=`git remote -v | grep origin | tr ' ' '\t' | cut -f2 | head -n 1`
    if [[ "$remote" != *"@"* ]]; then
        host=`echo "$remote" | cut -d'/' -f3`
        repo=`echo "$remote" | cut -d'/' -f4-`

        remote="git@$host:$repo"
    fi
    # keep the part between the '@' and '.git' | replace ':' with '/' 
    echo "$remote" | sed 's/^[a-zA-Z \t]*@//;s/\.git$//' | tr -s ':' '/'
}

prep_origin_vars() {
    if [ $# -ne 1 ]; then
        echo "ERR: Wrong number of arguments for prep_origin_vars()"\
             " - required 1, found <$#>"
        print_help
        exit 100 
    fi
    host=`echo "$1" | cut -d'/' -f1`
    user=`echo "$1" | cut -d'/' -f2`
    repo=`echo "$1" | cut -d'/' -f3`
}

get_origin_ssh() {
    prep_origin_vars "$1"
    echo "git@$host:$user/$repo.git"
}

get_origin_http() {
    prep_origin_vars "$1"
    echo "https://$host/$user/$repo.git"
}

get_actions() {
    path="$git_meta_path/data/`uniq_git_repo_path`"
    # dir does not exist
    cd $path  
    echo */* | tr -s ' ' '\n' | cut -d'/' -f2 | sort -u
    cd $save_dir
}

get_diffs() {
    if [ $# -ne 1 ]; then
        echo "ERR: Wrong number of arguments for get_diffs()"\
             " - required 1, found <$#>"
        print_help
        exit 200 
    fi
    path="$git_meta_path/data/`uniq_git_repo_path`"
    # dir does not exist
    cd $path  
    echo $1/diff/* | tr -s ' ' '\n' | cut -d'/' -f3 
    cd $save_dir
}

meta_pull() {
    if [[ ! -d "$git_meta_path/.git" ]]; then
        echo "WARN: No .git directory <$git_meta_path/.git>"\
             " - cloning <$git_meta_remote>!"
        [[ ! -d "$git_meta_path" ]] && mkdir -p "$git_meta_path"
        if ! git clone "$git_meta_remote" "$git_meta_path"; then
            echo "ERR: Clonning <$git_meta_remote> failed - exiting!"
            print_help
            exit 20
        fi
    fi
    cd "$git_meta_path" 
    git pull 
    cd "$save_dir" 
}

meta_record() {
    if [[ ! -d "$git_root" ]]; then 
        echo "ERR: git_root <$git_root> does not exist"
        print_help
        exit 30 
    fi
    if [[ ! -d "$git_meta_path/.git" ]]; then
        echo "ERR: Directory <$git_meta_path/.git> does not exist"
        print_help
        exit 31 
    fi
    cd "$git_root" 
    for repo in *; do
        cd "$git_root/$repo"
        if [[ ! -d .git ]]; then
            echo "WARN: <$git_root/$repo> is not a git repository - skipping!"
            continue
        fi
        
        path="$git_meta_path/data/`uniq_git_repo_path`/$device_id"

        [[ -d "$path" ]] && rm -r "$path" # add -f after testing
        [[ ! -d "$path" ]] && mkdir -p "$path"
        pwd

        git rev-parse HEAD > "$path/HEAD"
        git rev-parse --short HEAD > "$path/HEAD_short"
        git status --short > "$path/status_short"
        git status > "$path/status"
        git cherry -v > "$path/cherry_v"
        git log --max-count "$git_depth" --graph --oneline > "$path/log_graph_oneline"
        git log --max-count "$git_depth" --oneline > "$path/log_oneline"
        git log --max-count "$git_depth" --pretty="%H" > "$path/log_H"
        git branch --verbose > "$path/branch_verbose"
        [[ ! -d "$path/diff" ]] && mkdir "$path/diff"
        for hash in `git cherry -v | cut -d' ' -f2`; do
            git diff "$hash^" "$hash" > "$path/diff/$hash"
        done
        git diff --staged > "$path/diff/staged"
        git diff > "$path/diff/unstaged"
    done
    cd "$save_dir"
}

meta_commit() {
    if [[ ! -d "$git_meta_path/.git" ]]; then
        echo "ERR: Directory <$git_meta_path/.git> does not exist"
        print_help
        exit 40 
    fi
    cd "$git_meta_path" 
    git add .
    if git diff --cached --exit-code >/dev/null; then
        echo "WARN: Git states did not change - nothing to commit."
    else
        echo "commit"
        if [[ -z ${1+x} ]]; then
            git commit -m "Device: $device_id"
        else
            git commit -m "$1"
        fi
    fi
    cd "$save_dir" 
}

meta_push() {
    if [[ ! -d "$git_meta_path/.git" ]]; then
        echo "ERR: Directory <$git_meta_path/.git> does not exist"
        print_help
        exit 50 
    fi
    cd "$git_meta_path" 

    if [[ -z "`git cherry -v`" ]]; then
        echo "WARN: Git states did not change - nothing to push."
    else
        echo "push"
        git push 
    fi

    cd "$save_dir" 
}

# data_xxx fuctions are for remote data processing

data_origin() {
    cd "$git_meta_path/data" 
    for repo in */*/*; do
        path="$git_meta_path/data/$repo"
        origin_path="$path/origin"
        tmp_origin=`mktemp -d`
        echo "$repo"
        if ! git clone --depth $git_depth `get_origin_ssh $repo` "$tmp_origin"; then
            echo "WARN: Can't clone <$repo> via ssh - trying https" 
            if ! git clone --depth $git_depth `get_origin_http $repo` "$tmp_origin"; then
                echo "ERR: Can't clone <$repo> via https." 
                cd "$git_meta_path/data" 
                rm -rf "$tmp_origin"
                continue
            fi
        fi

        [[ ! -d "$origin_path" ]] && mkdir -p "$origin_path"
        cd "$tmp_origin"

        git rev-parse HEAD > "$origin_path/HEAD"
        git rev-parse --short HEAD > "$origin_path/HEAD_short"
        git log --max-count "$git_depth" --pretty=format:%H > "$origin_path/log_H"

        cd "$git_meta_path/data" 
        rm -rf "$tmp_origin"
    done
}

data_delta() {
    cd "$git_meta_path/data" 
    for repo in */*/*; do
        path="$git_meta_path/data/$repo"
        origin_path="$path/origin"
        if [[ ! -d "$origin_path" ]]; then
            echo "WARN: No origin data for <$path>"
            continue
        fi
        cd "$path"
        for device in *; do 
            [[ "$device" == "origin" ]] && continue 

            if diff -q origin/log_H "$device/log_H"; then
                echo "0" > "$path/$device/origin_delta"
            else
                diff_line=`diff origin/log_H "$device/log_H" -n | head -n 1`
                delta_value=`echo $diff_line | cut -d' ' -f2`
                if [[ "$diff_line" == d* ]]; then
                    # behind
                    let "delta_value *= -1"
                fi
                echo "$delta_value" > "$path/$device/origin_delta"
            fi
        done
        cd "$git_meta_path/data" 
    done
    
}

data_process() {
    if [[ "$device_id" != "REMOTE" ]]; then
        read -r -p "WARN: device_id != 'REMOTE' - do you want to run data processiong locally? [Y/n] " response
        if [[ "$response" =~ "^([nN]+$" ]]; then
            echo "WARN: Exiting!"
            exit 0
        fi
    fi
    
    data_delta
    meta_commit "Delta data [ci skip]"
    meta_push
}

if [ $# -lt 1 ]; then
    echo "ERR: Not enough arguments - found <$#>, required 1 or more - exiting!"
    print_help
    exit 1
fi

# default config
git_path=~/git
git_meta_path=~/.cache/git-meta-status
git_depth=24

# non-interactive git clone
export GIT_TERMINAL_PROMPT=0

# load config if exists
if [ -f "$config_path" ]; then 
    source "$config_path"
else
    echo "WARN: config file <$config_path> does not exist"\
         " - consider creating it."
fi

save_dir=`pwd`

case $1 in
    help)
        print_help
        exit 0
        ;;
    meta)
        if [ $# -lt 2 ]; then
            echo "ERR: Not meta action found - exiting!"
            print_help
            exit 2
        fi
        case $2 in
            session-exit)
                meta_pull
                meta_record
                meta_commit
                meta_push
                ;;
            actions)
                get_actions
                ;;
            devices)
                cat "$git_meta_path/devices"
                ;;
            meta_actions)
                echo "session-start session-exit init actions devices meta_actions diffs"
                ;;
            diffs)
                if [[ $# -lt 3 ]]; then 
                    echo "ERR: No device for 'igit meta diffs DEVICE' command - exiting!"
                    print_help
                    exit 5
                fi
                get_diffs "$3"
                ;;
        esac
        ;;
    diff)
        if [[ $# -lt 3 ]]; then
            echo "ERR: Not enough arguments for 'igit diff DEVICE COMMITISH' command - exiting!"
            print_help
            exit 5
        fi
        path="$git_meta_path/data/`uniq_git_repo_path`"
        cd $path  
        if [[ ! -f "$2/diff/$3" ]]; then
            echo "ERR: File <$2/diff/$3> does not exist - exiting!"
            print_help
            exit 5
        fi
        cat $2/diff/$3 
        ;;
    *)
        path="$git_meta_path/data/`uniq_git_repo_path`"
        cd $path  
        if [[ $# -lt 2 ]]; then
            hits=0 
            for device in *; do
                [[ ! -f "$device/$1" ]] && continue
                printf "[igit] Device <%s>:\n" "$device"
                cat "$device/$1"
                let "hits++"
            done
            if [[ $hits -eq 0 ]]; then 
                echo "ERR: Invalid action <$1>"
                print_help
                exit 3
            fi
        else
            if [[ ! -f "$2/$1" ]]; then 
                echo "ERR: Invalid action <$1> and device <$2> combination."
                print_help
                exit 4
            else
                cat $2/$1
            fi
        fi
        #echo $actions
        ;;
esac

